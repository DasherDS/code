### 冒泡排序

| 原始数组 |  3   |  6   |  4   |  2   |  11  |  10  |  5   |           |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :-------: |
|  第一趟  |  3   |  4   |  2   |  6   |  10  |  5   |  11  | 比较 6 次 |
|  第二趟  |  3   |  2   |  4   |  6   |  5   |  10  |  11  | 比较 5 次 |
|  第三趟  |  2   |  3   |  4   |  5   |  6   |  10  |  11  | 比较 4 次 |
|  第四趟  |  2   |  3   |  4   |  5   |  6   |  10  |  11  | 比较 3 次 |
|  第五趟  |  2   |  3   |  4   |  5   |  6   |  10  |  11  | 比较 2 次 |
|  第六趟  |  2   |  3   |  4   |  5   |  6   |  10  |  11  | 比较 1 次 |

---

**具体步骤**

1. 比较第1个数与第2个数，将小数放在前面，大数放在后面。
2. 比较第2个数与第3个数，这时第2个数应该是第1个和第2个数的最大值，它们会重复步骤1的行为，将大数放在后面，如此循环，直到倒数第1个数与倒数第2个数相比较，最后，末尾的数是这个数组中的最大值。这是第一次遍历。
3. 开始下一次遍历，数组有`n`个元素，那么就遍历`n-1`次。



```javascript
const arr = [2, 5, 3, 4, 9, 8, 1, 6, 10];

const bubbleSort = (arr) => {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i; j++) {
      // i 增大，内层循环比较次数n-i 因为第一趟的时候已经比较过了
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1); // swap 为交换位置的函数  js文件内有
      }
    }
  }
};
```



> 思考
>
> 如果原数组是有序的比如 [ 1, 2 ,3 ,4 ]，其实可以不需要比较的，可以在内部循环中加上标志位。在一次外循环中，如果满足比较条件则进行交换，并更改标志位，如果在外层循环中标志位没有动过，说明原数组是有序的无须交换。
>
> 每次排序结束后最后一个元素是最大的可以使用临时变量`swapPos`记录交换的位置。内部循环结束后将最后一个交换元素的位置赋值给`k`，这样可以节省下一轮内部循环时从位置`k`到`n-i`的比较开销。



```javascript
const bubbleSort2 = (arr) => {
  if (!arr) return;
  const len = arr.length;
  let k = len - 1;
  let swapPos = 0;

  for (let i = 0; i < len; i++) {
    let hasSore = true;
    for (let j = 0; j < k; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1);
        hasSore = false;
        swapPos = j;
      }
    }
    if (hasSore) {
      break;
    }
    k = swapPos;
  }
};
```

