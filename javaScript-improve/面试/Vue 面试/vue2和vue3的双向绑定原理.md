### `vue2`和`vue3`的双向绑定原理

#### `vue2` 的双向绑定

`vue2` 中的双向绑定依赖于 `Object.defineProperty` 的 数据劫持和发布订阅模式。在`vue2`中 当创建`vue`实例时，它会递归便利数据对象的每一个属性，并通过 `Object.defineProperty` 将他们变成 `getter` 和 `setter`

1. 数据劫持：数据初始化时，`vue2`使用 `Object.defineProperty`为每个属性添加 `getter` 和 `setter`，劫持属性的读取和设置操作
2. 依赖收集：当属性被访问时，`getter` 会将依赖（观察者 `watcher`）收集到依赖管理器（`Dep`）中。
3. 更新触发：当属性的值发生变化时，`setter` 会通知依赖管理器触发所有与该属性相关的 `watcher`从新执行，进行试图更新。

局限性：

- `Object.defineProperty` 不能检测到对象属性的添加和删除，因此 `vue2` 不能直接检测到数组和对象深层次的变化。
- 对象的嵌套层级较多时，性能会受到影响，因为它需要递归遍历每个属性。



#### vue3 的双向绑定

`vue3` 引入了 `Proxy` 代理，并重写了响应式系统，使用了更加高效的 `reactive` 和 `ref` 来实现数据响应

1. 响应式代理：`vue3` 使用 `Proxy` 来代理整个对象，这样就可以拦截对象上的所以操作（包括属性的读取、设置、新增、删除等），无需递归遍历对象的每一个属性。
2. 依赖收集和触发更新：和 `vue2` 类似，当读取属性值时，`vue3` 会收集依赖，当属性值发生变化时，它会触发相应的 `watcher` 执行更新。`vue3` 的响应式系统实现了更细粒度的依赖追踪，避免了不必要的更新，提高了性能。
3. `Composition API` 的加入：`vue3` 引入的 `Composition API` 提供了更灵活的响应式变量和数据绑定方式，使得状态管理更加集中和模块化，尤其适合大型应用的开发。





相比 `vue2` `vue3` 的`Proxy` 代理方式具有以下优势

- 可以监听对象的新增和删除操作，不在局限于初始化时定义的属性
- 性能更高，因为 `Proxy` 能直接监听到整个对象，而不是递归到每一个属性
- `Composition API` 的响应式函数使得代码更具可读性和复用性