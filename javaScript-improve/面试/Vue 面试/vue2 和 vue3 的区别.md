### vue2 和 vue3 的区别

1. **响应式系统**
   - `vue2` 使用 `object.defineProperty` 来实现其响应式系统。这种方法有一些限制。例如如法检测属性的添加或删除，以及无法直接处理数组索引和长度变化。
   - `vue3` 采用了基于`ES6 Proxy` 的响应式系统，这允许`vue` 拦截对象的任何属性的读取和写入操作，提供更强大的灵活的响应式能力。这也使得`vue3` 能够检测属性的添加和删除，以及更有效的处理数组更新。
2. **组合式API**
   - `vue2` 主要通过选项式`API`进行组件的逻辑组织
   - `vue3` 引入了组合式`API`，这为逻辑复用和代码组件提供了更灵活的方式。
3. **性能相关**
   - `vue3` 在性能方面有显著提升。它包括更小的打包大小、更快的虚拟`DOM` 重写，更高效的组件初始化等
   - `vue2`相比执行在性能方面相对较慢，尤其是在处理大型应用和复杂组件时
4. **typescript 支持**
   - `vue3` 一开始就是 `ts` 编写，提供更好的 `ts` 支持
   - `vue2` 对 `ts` 的支持是有限的，通常需要额外的配置和工具来实现更好的集成
5. **新特性和改进**
   - `vue3` 引入了多个新特性，如`teleport、fragment、suspense`等，为开发提供了更多的可能性和便利
6. **`Fargment`**
   - `vue3` 允许多个根节点 这使得组件模版可以多个并列的根元素
   - `vue2` 要求每个组件必须有一个单独的跟节点
7. **自定义渲染器API**
   - `vue3` 提供了自定义渲染器`API`，允许开发者创建自己的渲染逻辑
8. **更好的模块化**
   - `vue3` 对内部模块进行了更好的分离，使`tree-shaking`更加有效，有助于减小最终的打包体积
9. **静态元素提升（static Hoisting）**
   - `vue2` 中 模版中的所有元素在每次重新渲染是都会被创建的新的虚拟节点（`VNodes`），包括静态元素（不变的HTML和文本）
   - `vue3` 引入了静态元素提升的概念。在编译模版时，vue3会检测出静态内容并将其提升，意味着这些内容只在初次渲染时创建一次，后续的渲染中，静态内容会被重用，从而减少渲染和开销和提升了性能
10. **虚拟节点静态标记（patch flag）**
    - `vue2` 在更新组件时，会进行相对全面的虚拟DOM比较，这可能会导致性能开销
    - `vue3` 引入了`patch flag`这是一种优化技术，它在编译时标记虚拟节点的动态部分。这样在组件更新时，vue只需要关注这些被标记的部分，而不是整个组件树，从而显著提升了性能
11. **声明周期变化**
    - vue2 提供了一系列的生命周期钩子
    - vue3对这些生命周期钩子进行了重命名调整，以更好的与`Composition API` 配合
12. **打包体积优化**
    - vue2 的打包体积相对较大，尤其是包含了全框架的所有特效
    - vue3 进行了大量的打包体积优化，采用了更有效的树摇（`tree-shaking`）机制，允许去除未使用的代码部分。这意味着如果你只使用vue的一部分功能，最终打包出来的文件会更小